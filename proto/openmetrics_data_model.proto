syntax = "proto3";

package openmetrics;
option go_package = ".;openmetrics";

import "google/protobuf/timestamp.proto";

message MetricSet {
  repeated MetricFamily metric_families = 1;
}

message MetricFamily {
  string name = 1;

  MetricType type = 2;

  string unit = 3;

  string help = 4;

  repeated Metric metrics = 5;
}

enum MetricType {
  UNKNOWN = 0;
  GAUGE = 1;
  COUNTER = 2;
  STATE_SET = 3;
  INFO = 4;
  HISTOGRAM = 5;
  GAUGE_HISTOGRAM = 6;
  SUMMARY = 7;
}

message Metric {
  repeated Label labels = 1;

  repeated Point points = 2;
}

message Label {
  string name = 1;

  string value = 2;
}

message Point {
  oneof value {
    UnknownValue unknown_value = 1;
    GaugeValue gauge_value = 2;
    CounterValue counter_value = 3;
    HistogramValue histogram_value = 4;
    StateSetValue state_set_value = 5;
    InfoValue info_value = 6;
    SummaryValue summary_value = 7;
  }

  google.protobuf.Timestamp timestamp = 8;
}

message UnknownValue {
  oneof value {
    double double_value = 1;
    int64 int_value = 2;
  }
}

message GaugeValue {
  oneof value {
    double double_value = 1;
    int64 int_value = 2;
  }
}

message CounterValue {
  oneof total {
    double double_value = 1;
    uint64 int_value = 2;
  }

  google.protobuf.Timestamp created = 3;

  Exemplar exemplar = 4;
}

// Bucket boundary is inclusive at lower bound, exclusive at upper bound.
// Bucket count supports both integer and double.
// Use integer count whenever possible as it is efficiently encoded as varint.
message HistogramValue {
  // Sum of values represented by this histogram
  oneof sum {
    double double_value = 1;
    int64 int_value = 2;
  }

  // Number of values represented by this histogram
  oneof count {
    double double_count = 3;
    int64 int_count = 4;
  }

  google.protobuf.Timestamp created = 5;

  oneof buckets {
    Linear linear_buckets = 6;
    Exponential exponential_buckets = 7;
    Explicit explicit_buckets = 8;
  }

  HistogramProducer histogram_producer = 9;

  // A consumer may use HistogramProducer as a hint to deserialize a histogram
  // into the producer's format.
  enum HistogramProducer {
    UNKNOWN = 0;
    HDRHISTOGRAM = 1;
    DDSKETCH = 2;
    CIRCLLHIST = 3;
    DYNAHIST = 4;
  }

  // Linear buckets. Bucket n's lower bound is "offset + width * n"
  message Linear {
    double offset = 1;
    double width = 2;
    uint32 num_of_buckets = 3;
    BucketCounts bucket_counts = 4;
  }

  // Exponential buckets.
  // Bucket n's lower bound is "reference * (base ^ n)"
  // "reference" should be set to a number that can be exactly represented by a double type.
  // Negative bucket index is allowed so that reference can be set to a convenient value such as 1.
  // If negative index were not allowed, reference has to be set at or below the smallest tracked number.
  // When reference is close to zero, any inaccuracy in its "double" representation would
  // result in a large error in higher indexes.
  message Exponential {
    double reference = 1;
    double base = 2;

    // Exponential scale cannot represent zero. So we need a special counter for zero.
    oneof counterForZero {
      double double_count = 3;
      uint64 int_count = 4;
    }

    // Negative numbers are tracked via their absolute values.
    BucketCountsWithIndexOffset bucket_counts_for_positive_numbers = 5;
    BucketCountsWithIndexOffset bucket_counts_for_negative_numbers = 6;

    // Certain histograms (such as HdrHistogram) further divide an exponential bucket
    // into multiple linear subbuckets.
    // num_of_linear_subbuckets at 1 or 0 (default) means no linear subbuckets.
    // When subbuckets are present, bucket_counts must start on the first subbucket in an
    // exponential bucket. Bucket_counts need not end on the last subbucket in an
    // exponential bucket.
    // Example of base 2 exponential buckets, with 4 linear subbuckets:
    // Bucket boundary:  1 1.25 1.5 1.75 2 2.5 3 3.5 4 5  6  7  8
    // bucket index:     0 1    2   3    4 5   6 7   8 9 10 11 12
    uint32 num_of_linear_subbuckets = 7;

    // A bucket's logical index is physical index in bucket_counts plus index_offset.
    message BucketCountsWithIndexOffset {
      uint32 num_of_buckets = 1;
      sint32 index_offset = 2;
      BucketCounts bucket_counts = 3;
    }
  }

  // Explicitly enumerating all bucket bounds.
  message Explicit {
    uint32 num_of_buckets = 1;
    // bucket_bounds and bucket_counts must have num_of_buckets entries.
    repeated double bucket_bounds = 2;
    BucketCounts bucket_counts = 3;
  }

  message BucketCounts {
    // IntegerBucketCounts uses efficient encoding of the counts using varint.
    // Use DoubleBucketCounts only when necessary, because each count costs 8 bytes.
    oneof bucket_counts {
      IntegerBucketCounts integer_bucket_counts = 1;
      DoubleBucketCounts double_bucket_counts = 2;
    }

    // When present, exemplar must have num_of_buckets entries.
    repeated  Exemplar exemplar = 3;

    // In proto3, repeated fields of scalar numeric types use packed encoding by default.
    // Thus small counters will cost fewer bytes when encoded.
    message IntegerBucketCounts {
      repeated uint64 count = 1;
    }

    message DoubleBucketCounts {
      repeated double count = 1;
    }
  }
}

message Exemplar {
  double value = 1;

  google.protobuf.Timestamp timestamp = 2;

  repeated Label label = 3;
}

message StateSetValue {
  repeated State states = 1;

  message State {
    bool enabled = 1;

    string name = 2;
  }
}

message InfoValue {
  repeated Label info = 1;
}

message SummaryValue {
  oneof sum {
    double double_value = 1;
    int64 int_value = 2;
  }

  uint64 count = 3;

  google.protobuf.Timestamp created = 4;

  repeated Quantile quantile = 5;

  message Quantile {
    double quantile = 1;

    double value = 2;
  }
}
