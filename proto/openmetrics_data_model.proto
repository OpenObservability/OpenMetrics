syntax = "proto3";

package openmetrics;

import "google/protobuf/timestamp.proto";

message MetricSet {
  repeated MetricFamily metric_families = 1;
}

message MetricFamily {
  string name = 1;

  MetricType type = 2;

  string unit = 3;

  string help = 4;

  repeated Metric metrics = 5;
}

enum MetricType {
  UNKNOWN = 0;
  GAUGE = 1;
  COUNTER = 2;
  STATE_SET = 3;
  INFO = 4;
  HISTOGRAM = 5;
  GAUGE_HISTOGRAM = 6;
  SUMMARY = 7;
}

message Metric {
  repeated Label labels = 1;

  repeated Point points = 2;
}

message Label {
  string name = 1;

  string value = 2;
}

message Point {
  oneof value {
    UnknownValue unknown_value = 1;
    GaugeValue gauge_value = 2;
    CounterValue counter_value = 3;
    HistogramValue histogram_value = 4;
    StateSetValue state_set_value = 5;
    InfoValue info_value = 6;
    SummaryValue summary_value = 7;
  }

  google.protobuf.Timestamp timestamp = 8;
}

message UnknownValue {
  oneof value {
    double double_value = 1;
    int64 int_value = 2;
  }
}

message GaugeValue {
  oneof value {
    double double_value = 1;
    int64 int_value = 2;
  }
}

message CounterValue {
  oneof total {
    double double_value = 1;
    uint64 int_value = 2;
  }

  google.protobuf.Timestamp created = 3;

  Exemplar exemplar = 4;
}

// Bucket boundary is inclusive at lower bound, exclusive at upper bound.
// Bucket count supports both integer and double. Zero count buckets are allowed.
// Use integer count whenever possible as it is efficiently encoded as varint.
message HistogramValue {
  // Sum of values represented by this histogram
  oneof sum {
    double double_sum = 1;
    int64 int_sum = 2;
  }

  // Number of values represented by this histogram.
  // Should match sum of all bucket counts.
  oneof count {
    double double_count = 3;
    uint64 int_count = 4;
  }

  google.protobuf.Timestamp created = 5;

  oneof buckets {
    Linear linear_buckets = 6;
    Exponential exponential_buckets = 7;
    Explicit explicit_buckets = 8;
  }

  HistogramProducer histogram_producer = 9;

  // Min of values represented by this histogram
  oneof min {
    double double_min = 10;
    int64 int_min = 11;
  }

  // Max of values represented by this histogram
  oneof max {
    double double_max = 12;
    int64 int_max = 13;
  }

  // A consumer may use HistogramProducer as a hint to generate a histogram
  // in the producer's original format.
  enum HistogramProducer {
    UNLISTED = 0;
    HDRHISTOGRAM = 1;
    DDSKETCH = 2;
    CIRCLLHIST = 3;
    DYNAHIST = 4;
  }

  // Linear buckets. Bucket n's lower bound is "offset + width * n"
  message Linear {
    double offset = 1;
    double width = 2;
    uint32 num_of_buckets = 3;
    BucketCounts bucket_counts = 4;
  }

  // Exponential buckets.
  // Bucket n's lower bound is "reference * (base ^ n)"
  // Negative bucket index is allowed. Example of reference 1, base 2 buckets:
  // bucket lower bound: .125 .25 .5 1 2 4 8 16
  // bucket index:       -3   -2  -1 0 1 2 3 4
  message Exponential {
    double reference = 1;
    double base = 2;

    // Exponential scale cannot represent zero. So we need a special counter for zero.
    oneof counterForZero {
      double double_count = 3;
      uint64 int_count = 4;
    }

    // Negative numbers are tracked via their absolute values.
    BucketCountsWithIndexOffset bucket_counts_for_positive_numbers = 5;
    BucketCountsWithIndexOffset bucket_counts_for_negative_numbers = 6;

    // Certain histograms (such as HdrHistogram) further divide an exponential bucket
    // into multiple linear subbuckets.
    // num_of_linear_subbuckets at 1 or 0 (default) means no linear subbuckets.
    // Example of reference 1, base 2 exponential buckets, with 4 linear subbuckets:
    // Bucket lower bound: .5 .625 .75 .875 1 1.25 1.5 1.75 2 2.5 3 3.5 4
    // bucket index:       -4 -3   -2  -1   0 1    2   3    4 5   6 7   8
    uint32 num_of_linear_subbuckets = 7;

    // A bucket's logical index is physical index in bucket_counts plus index_offset.
    message BucketCountsWithIndexOffset {
      sint32 index_offset = 1;
      uint32 num_of_buckets = 2;
      BucketCounts bucket_counts = 3;
    }
  }

  // Explicitly enumerating all bucket lower bounds.
  // A bucket's upper bound comes from the next bucket's lower bound.
  // The last bucket's upper bound is assumed to be +infinity.
  // An extra bucket with zero count at the end is recommended to define
  // the upper bound of the bucket series.
  message Explicit {
    uint32 num_of_buckets = 1;
    // bucket_lower_bounds and bucket_counts must both have num_of_buckets entries.
    // The values in bucket_lower_bounds must be strictly increasing.
    repeated double bucket_lower_bounds = 2;
    BucketCounts bucket_counts = 3;
  }

  message BucketCounts {
    // IntegerBucketCounts uses efficient encoding of the counts using varint.
    // Use DoubleBucketCounts only when necessary, because each count costs 8 bytes.
    oneof bucket_counts {
      IntegerBucketCounts integer_bucket_counts = 1;
      DoubleBucketCounts double_bucket_counts = 2;
    }

    // When present, exemplars must have the same number of entries as the count list.
    repeated Exemplar exemplars = 3;

    // In proto3, repeated fields of scalar numeric types use packed encoding by default.
    // Thus small counters will cost fewer bytes when encoded.
    message IntegerBucketCounts {
      repeated uint64 count = 1;
    }

    message DoubleBucketCounts {
      repeated double count = 1;
    }
  }
}

message Exemplar {
  double value = 1;

  google.protobuf.Timestamp timestamp = 2;

  repeated Label label = 3;
}

message StateSetValue {
  repeated State states = 1;

  message State {
    bool enabled = 1;

    string name = 2;
  }
}

message InfoValue {
  repeated Label info = 1;
}

message SummaryValue {
  oneof sum {
    double double_value = 1;
    int64 int_value = 2;
  }

  uint64 count = 3;

  google.protobuf.Timestamp created = 4;

  repeated Quantile quantile = 5;

  message Quantile {
    double quantile = 1;

    double value = 2;
  }
}
