syntax = "proto3";

// The OpenMetrics protobuf schema which defines the protobuf
// wire format. 
// Ensure to intepret "required" as semantically required for a valid message.
// All string fields MUST be UTF-8 encoded strings.
package openmetrics;

import "google/protobuf/timestamp.proto";

// The top-level container type that is encoded and sent over the wire.
message MetricSet {
  // Each MetricPoints has one or more points for a single metric.
  repeated MetricPoints metric_points = 1;
}

// One or more timeseries for a single metric, where each timeseries has
// one or more points.
message MetricPoints {
  // Required.
  MetricDescriptor metric_descriptor = 1;

  repeated Timeseries timeseries = 2;
}

// A single timeseries.
message Timeseries {
  // Labels applying to all points.
  repeated Label label = 1;

  // If there is more than one point, all must have a timestamp field
  // and they must be in increasing order of timestamp.
  // If there is only one point and has no timestamp field, the receiver
  // will assign a timestamp.
  repeated Point point = 2;
}

// The descriptor of a metric.
message MetricDescriptor {
  // Required.
  // Names must match the regex [a-zA-Z_:][a-zA-Z0-9_:]* however colons are
  // reserved for monitoring system use, and names beginning with
  // underscores are reserved for monitoring-system internal use.
  string name = 1;

  // Required.
  MetricType MetricType = 2;

  // STATE_SETs and INFO types must not have a unit.
  // Must match the regexp [a-zA-Z_:][a-zA-Z0-9_:]*
  string unit = 3;

  // Optional description of the metric name.
  string description = 4;

  // Note: No bucketing is defined for a HISTOGRAM in the descriptor.
  // It is an implementation detail of the backend whether it can handle
  // changes in bucketing for a metric. Same for SUMMARY (quantiles are
  // not defined here), and STATE_SET (the set of possible values is
  // defined in each point).
}

// The type of a metric.
enum MetricType {
  // Unknown must use double or int valued points.
  UNKNOWN = 0;
  // Gauge must use double or int valued points.
  GAUGE = 1;
  // Counter must use double or int valued points.
  COUNTER = 2;
  // State set must use state set value points.
  STATE_SET = 3;
  // Info provides information about the target being monitored
  // and must use info value points.
  INFO = 4;
  // Cumulative histogram must use histogram value points.
  CUMULATIVE_HISTOGRAM = 5;
  // Gauge histogram must use histogram value points.
  GAUGE_HISTOGRAM = 6;
  // Summary quantiles are not recommended, since they cannot be
  // aggregated.
  SUMMARY = 7;
}

// A name-value pair. These are used in multiple places: identifying
// timeseries, value of INFO metrics, and exemplars in Histograms.
message Label {
  // Required.
  string name = 1;

  // Required.
  string value = 2;
}

// A point in a timeseries.
message Point {
  // Required.
  oneof value {
    double double_value = 1;
    int64 int_value = 2;
    HistogramValue histogram_value = 3;
    StateSetValue state_set_value = 4;
    InfoValue info_value = 5;
    SummaryValue summary_value = 6;
  }

  // Not required, but SHOULD be specified for COUNTER, SUMMARY or
  // CUMULATIVE_HISTOGRAM type.
  //
  // The cumulative value is over the time interval 
  // (start_timestamp, timestamp].
  // If start_timestamp is present and timestamp is absent,
  // the backend assigned timestamp may be used to construct the time
  // interval.
  google.protobuf.Timestamp start_timestamp = 7;

  // Not required.
  // If not specified, the timestamp will be decided by the backend.
  google.protobuf.Timestamp timestamp = 8;
}

// Value for CUMULATIVE_HISTOGRAM or GAUGE_HISTOGRAM point.
message HistogramValue {
  // Not required, but SHOULD be specified.
  double sum = 1;

  // Not required, but SHOULD be specified.
  uint64 count = 2;

  // Required.
  BucketOptions bucket_options = 3;

  // `BucketOptions` describes the bucket boundaries used to create a
  // histogram. The buckets can be in a linear sequence, an
  // exponential sequence, or each bucket can be specified explicitly.
  // `BucketOptions` does not include the number of values in each bucket.
  //
  // A bucket has an exclusive lower bound and an inclusive upper bound for the
  // values that are counted for that bucket. That is, buckets are
  // cumulative. The upper bound of successive buckets must be increasing.
  // There is an implicit overflow bucket that extends up to +infinity.
  message BucketOptions {
    // Exactly one of these three fields must be set.
    oneof options {
      // The linear bucket.
      Linear linear_buckets = 1;

      // The exponential buckets.
      Exponential exponential_buckets = 2;

      // The explicit buckets.
      Explicit explicit_buckets = 3;
    }

    // Specifies a linear sequence of buckets that add the same constant width
    // to the previous bucket (except the overflow bucket). This implies
    // a constant absolute uncertainty on the specific value of a sample.
    //
    // There are `num_explicit_buckets` (N) buckets plus the overflow
    // bucket. Bucket `i` (0 <= i < N) has upper bound : offset + (width * i).
    // Note that when offset = 0, bucket 0 represents the interval (0, 0].
    message Linear {
      // Required.
      // Must be greater than 0.
      uint32 num_explicit_buckets = 1;

      // Required.
      // Must be greater than 0.
      double width = 2;

      // Required.
      // Must be >= 0.
      double offset = 3;
    }

    // Specifies an exponential sequence of buckets that have an upper bound
    // that is proportional to the value of the upper bound of the previous
    // bucket. This implies a constant relative uncertainty on the specific
    // value of a sample.
    //
    // There are `num_exponential_buckets` + 1 (N) buckets plus the overflow
    // bucket.
    // Bucket 0 represents the interval (0, 0].
    // Bucket `i` (1 <= i < N) has upper bound :
    //   scale * (growth_factor ^ (i - 1)).
    message Exponential {
      // Required.
      // Must be greater than 0.
      uint32 num_exponential_buckets = 1;

      // Required.
      // Must be greater than 1.
      double growth_factor = 2;

      // Required.
      // Must be greater than 0.
      double scale = 3;
    }

    // Specifies a set of buckets with arbitrary upper-bounds.
    //
    // There are `size(bounds)` (N) explicit buckets plus the overflow bucket.
    // Bucket `i` (0 <= i < N) has upper bound: bounds[i].
    // The `bounds` field must contain at least one element.
    message Explicit {
      // The values must be monotonically increasing and >= 0.
      repeated double bounds = 1;
    }

  }

  // The number of values in each bucket of the histogram, as described in
  // `bucket_options`.
  //
  // `bucket_counts` must contain N + 1 values. The sum of BucketCount::counts
  // must equal HistogramValue::count.
  //
  // The order of the values in `bucket_counts` follows the bucket numbering
  // schemes described for the three bucket types.
  repeated BucketCount bucket_counts = 4;

  message BucketCount {
    // Required.
    // Count is the number of values for a bucket of the histogram.
    uint64 count = 1;

    // Not required.
    // An example of a value that fell into this bucket.
    Exemplar exemplar = 2;

    message Exemplar {
      // Required.
      // The value of the example.
      double value = 1;

      // The timestamp of the example. Optional but SHOULD set it.
      google.protobuf.Timestamp timestamp = 2;

      // Additional information about the example value // (e.g. trace id).
      // The sum of lengths of all the strings in all the labels must not
      // exceed 64 UTF-8 characters.
      repeated Label label = 3;
    }
  }
}

// Value for STATE_SET point.
message StateSetValue {
  // Each state must have a unique name. Any number of states may be enabled.
  repeated State states = 1;

  message State {
    // Required.
    bool enabled = 1;

    // Required.
    string name = 2;
  }
}

// Value for INFO point.
message InfoValue {
  repeated Label info = 1;
}

// Value for SUMMARY point. The start_timestamp only applies to the sum 
// and count. The quantiles can be reset at arbitrary unknown times.
message SummaryValue {
  // Not required, but SHOULD be specified. This is for compatibility 
  // since some common systems do not expose them.
  double sum = 1;

  // Not required, but SHOULD be specified. This is for compatibility 
  // since some common systems do not expose them.
  uint64 count = 2;

  repeated Quantile quantile = 3;

  message Quantile {
    // Required. Must be in the interval [0.0, 1.0].
    double quantile = 1;

    // Required.
    double value = 2;
  }
}
